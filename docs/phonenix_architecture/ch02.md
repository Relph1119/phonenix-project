# 第二部分 架构师的视角

## 1 访问远程服务

### 1.1 远程服务调用

- 进程间通信（IPC）的解决方法
  - 管道/具名管道：用于解决进程间传递少量字符流或字节流
  - 信号：用于通知目标进程有某种事件发生
  - 信号量：用于在两个进程之间同步协作
  - 消息队列：用于进程间传递数据量较多的通信
  - 共享内存（效率最高）：运行多个进程访问同一块公共内存空间
  - 本地套接字接口：用于不同机器之间的进程通信

### 1.2 三个基本问题

- 如何表示数据：序列化和反序列化
- 如何传递数据：Wire Protocol，传输协议
- 如何表示方法：接口描述语言（Android接口定义语言、Web服务描述语言、JSON Web服务协议）

### 1.3 RPC的发展

- 面向对象：RMI、.NET Remoting
- 性能：gRPC（支持多路复用和Header压缩）、Thrift（基于传输层的TCP协议）
- 简化：JSON-RPC


### 1.4 REST设计风格
- 术语定义
    - 资源
    - 表征：不同的形式
    - 状态：在特定语境中的上下文信息
    - 转移：服务端将资源表征从一个状态转移到另一个状态
    - 统一接口：GET、HEAD、POST、PUT、DELETE、TRACE、OPTION
    - 超文本驱动：通过超文本内部的链接进行跳转
    - 自描述信息：Content-Type

- RESTful系统特点
  1. 客户端与服务端分离：用户界面所关注的逻辑和数据存储的逻辑分离
  2. 无状态：每次从客户端发送的请求中，仅包含必要的上下文信息
  3. 可缓存：将部分客户端的应答缓存
  4. 分层系统：客户端一般不需要知道是否直接连接到最终的服务器（透明访问）
  5. 统一接口：面向资源编程
  6. 按需代码：将可执行的软件程序从服务端发送到客户端，WebAssembly

- RMM（Richardson成熟度模型）
  - 第0级：完全不REST
  - 第1级：开始引入资源的概念，使用资源ID进行请求
  - 第2级：引入统一接口，映射到HTTP协议的方法上，把不同业务需求抽象为对资源的增删改等操作
  - 第3级：超媒体控制，请求回应能够描述清楚后续可能发生的状态转移

- 不足与争议
  1. 面向资源的编程思想只适合做CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑
  2. REST与HTTP完全绑定，不适合应用于要求高性能传输的场景中
  3. REST不利于事务支持
  4. REST没有传输可靠性支持
  5. REST缺乏对资源进行“部分”和“批量”处理的能力
    
## 2 事务处理

### 2.1 事务特性（刚性事务）
- 原子性（Atomic）
- 隔离性（Isolation）
- 持久性（Durability） 
- 一致性（Consistency）

### 2.2 本地事务

**存在的问题：**
- 未提交事务，写入后崩溃
- 已提交事务，写入前崩溃

**解决方法：**
1. 提交日志（Commit Logging）
- 原理：   
  （1）日志一旦成功写入Commit Record，事务成功  
  （2）如果出现修改时数据崩溃，重启后通过日志信息恢复现场  
  （3）如果日志没有成功写入Commit Record，事务失败  
- 缺点：占用大量的内存缓冲区 
  
2. 提前写入日志（Write-Ahead Logging）
- 原理：  
（1）分析阶段（幂等性）：从最后一次检查点开始扫描日志，找出所有没有End Record的事务，组成待恢复的事务集合  
（2）重做阶段（幂等性）：找出所有包含Commit Record日志，将日志修改的数据写入磁盘，写完之后新增一条End Record，移出待恢复事务集合  
（3）回滚阶段：剩余恢复事务集合进行回滚操作  


3. 加锁同步
- 锁的类型：写锁、读锁、范围锁
- 隔离级别：   
（1）可串行化：对事务所有读、写的数据全部加上读锁、写锁和范围锁  
（2）可重复读：存在幻读问题  
（3）读已提交：存在不可重复读问题  
（4）读未提交：存在脏读问题  
- MVCC（多版本并发控制）：读取优化策略，对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版本与老版本共存，达到读取时完全不加锁的目的

4. 全局事务
- 事务提交阶段（2PC协议，两段式提交）
    - 准备阶段：投票阶段，询问所有参与者是否准备好提交，回复Prepared或Non-Prepared，即在重做日志中记录全部事务提交操作所要做的内容
    - 提交阶段：执行阶段，所有参与者全Prepared则Commit，否则将完成事务状态改为Abort持久化，执行回滚

- 缺点：
  - 单点问题：同步等待问题
  - 性能问题：瓶颈在于参与者集群中最慢的那个处理操作耗时
  - 一致性风险：提交阶段的一致性

- 三段式提交（3PC）：避免单点问题
  - CanCommit：询问阶段，参与者根据自身状态，评估该事务是否能顺利完成
  - PreCommit
  - DoCommit

5. 共享事务
- 理论可行方案：让各个服务共享数据连接
- 解决方案：使用交易服务器（消息队列服务器）

6. 分布式事务
- CAP理论
  - 一致性（Consistency）：数据在任何时刻、任何分布式节点中看到的都是符合预期的
  - 可用性（Avaliability）：系统不间断地提供服务的能力
  - 分区容忍性（Partition Tolerance）：分布式环境中部分节点因网络原因彼此失联后，系统仍能正确地提供服务的能力

- CAP特点
  - 放弃分区容忍性（CA without P）：传统关系库集群
  - 放弃可用性（CP without A）：HBase
  - 放弃一致性（AP without C）：NoSQL库和支持分布式的缓存框架

- 柔性事务
  - 可靠事务队列：通过持续重试保证可靠性，最大努力交付
  - TCC事务：适用于业务隔离，主要包括Try（尝试阶段）、Confirm（确认执行阶段）、Cancel（取消执行阶段）
  - SAGA事务：把一个大事务分解为可以交错运行的一系列子事务集合

## 3 透明多级分流系统

### 3.1 客户端缓存
- 状态缓存：不经过服务器，客户端直接根据缓存信息对目标网站的状态判断
- 强制缓存：检查时刻点之前的时效，客户端在该时刻点之前一直持有和使用该资源的本地缓存副本
  - Expires：HTTP/1.0提出，主要受限于客户端的本地时间、无法处理涉及用户身份的私有资源、无法描述“不缓存”的语义
  - Cache-Control：HTTP/1.1提出
    - max-age和s-maxage：缓存有效时间，单位为秒
    - public和private：涉及用户身份的资源私有性
    - no-cache：资源不应该被缓存
    - no-store：不强制会话中相同URL资源的重复获取，但禁止浏览器、CDN等以任何形式保存该资源
    - no-transform：禁止以任何形式修改资源
    - min-fresh：建议服务器能返回一个不少于该时间的缓存资源
    - only-if-cached：不给客户端发送资源的具体内容 
    - must-revalidate：资源过期后，要从服务器中获取
    - proxy-revalidate：当代理、CDN资源过期后，从服务器中获取


- 协商缓存：基于变化检测的缓存机制
  - Last-Modified：资源的最后修改时间
  - If-Modified-Since：当客户端再次请求时，把之前收到的资源最后修改时间发送给服务端
  - ETag：资源的唯一标识，最强的缓存机制，但是性能最差
  - If-None-Match：当客户端再次请求时，把之前收到的资源唯一标识发送给服务端


### 3.2 域名解析

- 解析步骤：
（1）客户端先检查本地的DNS缓存，查看是否存在存活的域名的地址记录  
（2）客户端将地址发送给本机操作系统配置的本地DNS  
（3）本地DNS收到查询请求，按照域名的权威服务器逐级查询地址记录，直到根域名服务器为止  
（4）如果本地DNS不存在任何域名的权威服务器记录，逐级得到每一层权威服务器的地址记录  
（5）通过解释的域名服务器地址，使用智能线路策略，更快查询地址记录  

- 传输链路
  - HTTP传输对象的主要特征：数量多、时间短、资源小、切换快
  - 优化链路传输的方法：  
  （1）连接数优化：连接Keep-Alive机制（连接复用技术），让客户端对同一个域名长期持有一个或多个不会用完即断的TCP连接，可能存在“队首阻塞”问题，主要解决该问题可以采用多路复用技术（HTTP/2）：同一个TCP连接中传输的多个数据帧可以使用流ID进行区分，使得客户端将不同流中的数据重组出不同HTTP请求和响应的报文，对每个域名只维持一个TCP连接并以任意顺序传输任意数量的资源。  
  （2）传输压缩
       - 静态预压缩：提前将静态资源预先压缩成.gz文件，客户端接收到压缩版本的资源时，返回压缩后的版本
       - 即时压缩：整个压缩过程在内存的数据流中完成，显著提高首字节时间（TTFB）
       - 分块传输编码：用于解决Content-Length与持久连接的冲突问题
   （3）快速UDP网络连接：其中QUIC表示对每个流进行单独控制，面向移动设备


### 3.3 内容分发网络
- CDN路由解析步骤
    1. 将服务器IP地址在CDN服务商上注册为“源站”，得到CNAME
    2. DNS服务商将CNAME注册为一条CNAME记录
    3. 当访问时，由域名服务商解析CNAME，返回给本地DNS，链路解析由内容分发网络的调度服务接管
    4. 本地DNS查询CNAME时，由DNS服务器在所有能提供服务的CDN缓存节点选取一个最合适的CDN服务器，将它的IP代替为源站的IP
    5. 浏览器使用被替换的源站IP进行访问
    6. 经过内容分发后的CDN节点，可以代替源站提供请求资源


- 内容分发
  - 主动分发：由源站主动发起，将内容从源站或其他资源库推送到用户边缘的各个CDN缓存节点上
  - 被动回源：由用户访问触发，是全自动、双向透明的资源缓存过程；首次访问慢，不适合数据量较大的资源

- CDN特点
    - 加速静态资源分发
    - 安全防御
    - 协议升级
    - 状态缓存
    - 修改资源
    - 访问控制
    - 注入功能
    
### 3.4 负载均衡

**负载均衡的层级结构：**
- 数据链路层：修改请求的数据帧中的MAC地址，由二层交换机根据新的MAC目标地址转发到真实服务器的网卡上
- 网络层：通过负载均衡器的IP隧道传输数据包，并修改源地址和目标地址
- 应用层：正向代理（客户端侧）、反向代理（服务器侧）和透明代理（网络中间设备）

**负载均衡策略：**轮询均衡、权重轮询均衡、随机轮询、权重随机轮询、一致性哈希均衡、响应速度均衡、最少连接数均衡


### 3.5 服务端缓存
- 解决CPU压力、I/O压力
- 吞吐量：并发场景，避免数据竞争
  - 同步处理机制：访问数据时，完成缓存淘汰、统计、失效等状态变更操作，通过分段加锁减少竞争
  - 异步同步提交机制：将数据的读、写过程看作日志的提交过程

- 命中率
    - FIFO：优先淘汰最早进入被缓存的数据
    - LRU：优先淘汰最久未被访问过的数据
    - LFU：优先淘汰最不经常使用的数据
    - TinyLFU：基于LFU采用Sketch对访问数据进行分析
    - W-TinyLFU：结合LRU和LFU，将新纪录暂时存放Window Cache的前端LRU缓存

- 扩展功能
    - 加载器
    - 淘汰策略
    - 失效策略
    - 事件通知
    - 并发级别
    - 容量控制
    - 引用方式
    - 统计信息
    - 持久化

- 分布式缓存
    - 复制式缓存：缓存中所有数据在分布式集群的每个节点里面都有一份副本，直接从节点的进程内存中返回，主要代表是JBossCache、Infinispan
    - 集中式缓存（主流）：为异构语言提供服务，目前主流是Redis

- 缓存风险与应对出策略
    - 缓存穿透：查询的数据在数据库中不存在，增加数据库压力
    - 对业务逻辑，可以约定在一定时间内返回为空的Key值进行缓存
    - 对恶意攻击，设置布隆过滤器（判断某个元素是否存在于某个集合中）

- 缓存击穿：缓存中热点数据忽然失效
    - 加锁同步，以请求该数据的Key值为锁
    - 热点数据由代码来手动管理

- 缓存雪崩：大批不同的数据在短时间内一起失效
  - 提升缓存系统可用性，建立分布式缓存集群
  - 启用透明多级缓存
  - 将缓存的生存期从固定时间改为一个时间段内的随机时间

## 4 架构安全性

### 4.1 认证
        
- HTTP认证
  - Basic认证：以演示目的的认证方案
  - Digest：HTTP摘要认证
  - Bearer：基于OAuth 2规范来完成认证
  - HOBA：基于自签名证书的认证

- Web认证（表单认证）：WebAuthn规范（注册、认证）

### 4.2 授权
        
- 4A：Authentication（授权）、Authorization（认证）、Audit（审计）、Account（账号）
- 确保授权的过程可靠：常用的授权协议主要有OAuth 2和SAML 2.0
- 确保授权结果的可控：资源访问控制
  - 自主访问控制（DAC）
  - 强制访问控制（MAC）
  - 基于属性的访问控制（ABAC）
  - 基于角色的访问控制（RBAC）：角色拥有操作哪些资源的许可，包括RBAC-1（角色权限继承）、RBAC-2（角色职责分离）

- OAuth 2：以令牌代替用户密码作为授权的凭证
  - 授权码模式：第三方应用需要到授权服务器上进行注册之后，将授权码发到授权服务器，获得访问令牌
  - 隐式授权模式：授权服务器不会去验证第三方应用的身份
  - 密码模式：认证和授权被整合到同一个过程中
  - 客户端模式：第三方应用向授权服务器申请授权，得到访问令牌

### 4.3 凭证

- Cookie-Session
- JWT：用于认证授权
    - 组成：以JSON结构存储，包括令牌头（令牌的类型、令牌签名的算法）、负载（真正需要向服务端传递的消息）、签名（默认签名算法HMAC SHA256，加密与验证过程只能由中心化的授权服务）
    - 七项声明名称：iss（签发人）、exp（令牌过期时间）、sub（主题）、aud（令牌受众）、nbf（令牌生效时间）、iat（令牌签发时间）、jti（令牌编号）
    - 缺点：令牌难以主动失效、相对更容易遭受重放攻击、只能携带相当有限的数据、必须考虑令牌在客户端如何存储、无状态也不总是好的
                
### 4.4 保密强度
- 以摘要代替明文：不饿能防止弱密码被彩虹表攻击
- 盐值再做哈希：不能阻止加密结果被监听和窃取
- 盐值变为动态值防止冒认：不能阻止对服务的重放攻击
- 添加动态令牌：不能解决传输过程中被嗅探而泄漏信息的问题
- 启动HTTPS
- 物理设备存储的证书

### 4.5 传输
- 哈希算法：易变性、不可逆性
- 密码学算法：对称加密算法、非对称加密算法
  - 加密：公钥加密，私钥解码
  - 签名：私钥加密，公钥解码

- 数字证书
  - 信任：基于共同私密信息的信任、基于权威公证人的信任
  - 证书：由权威CA中心对特定公钥信息的一种公证载体
  - 内容：版本号、序列号、签名算法标识符、认证机构的数字签名、认证机构、有效期限、主题信息、公钥信息
  - 传输安全层（四次通信，HTTPS）
    - 客户端请求（Client Hello）：以明文形式向服务端提供支持的协议版本、32字节加密密钥、可选的SessionID、密码学算法套件、数据压缩算法、其他可扩展信息
    - 服务器回应（Server Hello）：以明文形式向客户端提供使用的TLS协议版本、第2个32字节加密的密钥、一个SessionID、服务端的密码学算法套件、服务端的数据压缩算法、其他可扩展信息、X.509证书、密码协商消息
    - 客户端确认（Client Handshake Finished）：验证服务器的证书合法性，从证书中取出服务器的公钥
    - 服务端确认（Server Handshake Finished）：向客户端确认通知包括编码改变通知、服务器握手结束通知

### 4.6 验证

- 可以在Bean上进行校验行为 
- 建议：
    1. 对校验项预置好默认的提示信息
    2. 将不带业务含义的格式校验注册放到Bean的类定义之上，将带业务逻辑的校验放到Bean的类定义的外面



